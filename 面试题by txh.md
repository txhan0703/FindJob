## 面试题by txh

### Mysql

- 数据库的三个基础范式

  ```
  1NF 每一列属性都是不可再分的属性，属性要具有原子性
  2NF 列之间要有一个主键，每个属性都要与主键相关，不能有部分依赖
  3NF 列之间不能有传递依赖，每个属性直接依赖于主键
  ```

- mysql的引擎

  ```
  innodb支持事务，mysiam不支持事务；innodb支持外键，mysiam不支持；innodb是聚集索引，mysiam是非聚集索引；mysiam支持全文索引，存储了表的行数；innodb最小的锁粒度是行锁，mysiam是表锁；
  
  - MyISAM存储: 如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎,比如bbs 中的 发帖表，回复表，还有批量添加MyISAM效率高
  - INNODB 存储: 对事务要求高，保存的数据都是重要数据，我们建议使用INNODB,比如订单表，账号表。
  - memory：数据放在内存，减少io，适合io量很大的场景
  ```

- MyISam和innodb的底层索引结构

  ```
  MyISAM索引文件和数据文件是分离的(非聚集)，索引的叶节点存放的是对应索引在文件系统中的数据地址编码，比如说查找id=49的元素时，是先索引树查询到49对应的数据文件地址，然后再拿着地址在数据文件中取出对应的数据，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据
  
  InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索
  ```

  

- 说下innodb事务隔离的级别

  ```
  ACID:原子性、一致性、隔离性、持久性
  
  并发问题：
  
  丢失修改：后修改了覆盖了之前的修改
  
  读脏数据：t1修改后t2读,t1又回滚了
  
  不可重复读：t2读取两次，其间t1修改，那么t2两次读取的不一样
  
  幻读：t2读取某个范围，期间t1插入insert或者删除delete，那么t2两次读取的不一样，和不可重复读区别在于insert，与加锁不一样
  ```

- 乐观锁和悲观锁：

  ```
  悲观锁的理念：一致性锁定锁，依靠数据库的锁机制
  
  乐观锁：版本记录version号的机制，即MVCC
  ```

  

- 简述一下读锁S和写锁X：

  ```
  读锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。
  
  写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。
  ```

  

- mysql索引的数据结构，联合索引的数据结构

  ```
  B+树，为什么用B+树？
  
  联合索引：最左前缀原则，联合索引的字段从左到右匹配。
  
  假设你在表的state、city和zip数据列上建立了复合索引。索引中的数据行按照state/city/zip次序排列，先判断最前的一个，从左到右排序判断建立B+树
  ```

  

### 网络

- OSI七层模型

  ```
  应用层 HTTP HTTPS dhcp
  表示层 
  会话层 
  传输层 TCP UDP
  网络层 IP...
  数据链路层
  物理层
  ```

- TCP、UDP的区别

  ```
  TCP面向连接，UDP面向无连接
  
  TCP面向字节流，UDP面向报文
  
  TCP可靠，因为有拥塞控制和丢包重传机制，而且是点对点传输，全双工的可靠信道，UDP不可靠，支持交互通信
  ```

- TCP的三次握手

  ```
  1：客户端发送SYN
  
  2：服务端发送SYN=1,ACK=1
  
  3：客户端发送ACK=1
  
  为啥两次不行？因为客户端知道他到服务端的连接已成功，但是服务端并不知晓连接是否成功，就会出现很多问题。比如说已失效的连接请求报文段又传送到了服务端，因而产生错误的新连接。
  ```

  

- 四次挥手

  ```
  1：客户端发送FIN
  
  2：服务端发送ACK=1
  
  3：服务端发送FIN=1，ACK=1
  
  4：客户端发送ACK=1
  
  为啥三次不行？因为客户端肯定要知道服务端已经断开连接了啊...
  服务端需要close_wait。服务器要知道客户端有没有断开连接，如果服务器的FIN+ACK信息客户端没有收到，客户端会一直处在等待状态。
  ```

- 为什么最后客户端要等待2MSL的时间

  ```
  1 保证客户端发送的最后一个ACK报文能到达服务器
  
  2 防止已经失效的连接请求又传过来，让本连接持续的时间内产生的所有报文都去掉
  ```

- TCP的流量控制、拥塞控制

     ```
     流量控制：接收端会把缓冲区信息告诉发送端 置0后窗口探测
     拥塞控制：慢启动，拥塞窗口 阈值
     ```

     

- TCP粘包问题

     ```
     由于TCP的Nagle算法（即把较小包合成数据块再封包）的原因。接收缓冲区中后一包数据的头紧接着前一包的尾。
     写入的数据大于缓冲区的大小会发生拆包，小于会发生粘包
     不及时读取缓冲区的，也会发生粘包现象。
     
     如何解决？
     1：数据包中包含数据包长度信息
     2：每个数据包封装为固定长度
     3：设置特殊符号作为边界
     ```

     

- cookie和session：

  ```
  cookie的数据存放在客户端的浏览器上，session的数据存放在服务器上。
  
  这也导致cookie不安全
  
  session会保存在服务器上，导致占用服务器的性能
  
  cookie保存的数据不能超过4K
  ```

  

- http和https：

          1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。
          
          2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。
          
          3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
          
          4、http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全
          
          这两个最主要的区别就是http是超文本传输协议，是明文传输的，https是ssl/tls+http构建的加密传输。
          https更安全，但是HTTPS连接缓存不如HTTP高效，流量成本高。

- get和post

  ```
  get的请求放在url里，post 放在requestbody里，这导致了get安全，post不咋安全
  get传输的数据量小，post大
  get效率比post好
  ```
  

- http1.0和http1.1

  ```
  http1.1比1.0增加的：长连接，新增了range头域支持只发送head和请求部分内容，增加了host处理
  2.0：多路复用，服务器推送，头信息和数据体都是二进制，头信息压缩
  ```

  

### Java

- GC的机制

  ```
  首先，堆和方法区需要gc
  GC常用算法有：标记-清除算法，标记-压缩算法，复制算法，分代收集算法。
  
  目前主流的JVM（HotSpot）采用的是分代收集算法。
  分代收集算法
  
  现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。
  ```

  ![image-20200724111736791](C:\Users\Too_K\AppData\Roaming\Typora\typora-user-images\image-20200724111736791.png)

### 操作系统

- 页面置换

  ```
  FIFO
  OPT
  LRU
  CLOCK：把所有页面都保存在一个类似时钟的环形链表，一个指针指向最老的页面。如果发生中断就首先检查表指针指向的页面，如果R位是0就换出，否则置0再寻找下一位。（NRU?）
  ```

- 磁盘调度：

  ```
  FCFS：先来先服务
  SSTF：最短寻道时间优先
  SCAN：电梯调度，不只考虑磁道距离，也考虑磁头的移动方向，就像电梯一样，先考虑方向，下一个访问对象是该方向最近的，直到无更外的磁道访问
  CSCAN：单向移动，不做返回移动，因为一般情况下磁头访问过的磁道请求密度较低，另一边的磁道可能密度较高
  ```

- 死锁

  ```
  互斥：某种资源一次只允许一个进程访问
  占有且等待：占有，同时还有资源未得到满足
  不可抢占：
  循环等待：
  
  如何避免？最好的是在使用前进行判断，只允许不会产生死锁的进程额外申请资源。
  银行家算法，实时统计
  ```

- 进程，程序，线程

  ```
  1：程序只是一组指令的有序集合，是一个静态的实体。进程是操作系统分配资源的基本单位，是一个动态的实体，反应了程序运行的动态过程。进程和程序也不是一一对应的。
  2：进程是一个独立单位，是系统进行资源分配和调度的基本单位，线程是包含在进程之中的，是进程中的实际执行流，是程序执行的最小单位。
  ```

  